diff --git a/tests/tools/TestApp/CMakeLists.txt b/tests/tools/TestApp/CMakeLists.txt
index fa3a80f..78adb2e 100644
--- a/tests/tools/TestApp/CMakeLists.txt
+++ b/tests/tools/TestApp/CMakeLists.txt
@@ -23,10 +23,17 @@ set(SRC src/input.c src/mcm.c src/misc.c src/json_context.cc)
 include_directories(${INC})
 
 # Add the executable
-add_executable(TxApp tx_app.c ${SRC})
-add_executable(RxApp rx_app.c ${SRC})
-
-
-target_link_libraries(TxApp PRIVATE memif ${CMAKE_THREAD_LIBS_INIT} ${BSD_LIB} mcm_dp)
-target_link_libraries(RxApp PRIVATE memif ${CMAKE_THREAD_LIBS_INIT} ${BSD_LIB} mcm_dp)
-
+add_executable(TxVideoApp tx_video_app.c ${SRC})
+add_executable(RxVideoApp rx_video_app.c ${SRC})
+add_executable(TxAudioApp tx_audio_app.c ${SRC})
+add_executable(RxAudioApp rx_audio_app.c ${SRC})
+add_executable(TxBlobApp tx_blob_app.c ${SRC})
+add_executable(RxBlobApp rx_blob_app.c ${SRC})
+
+
+target_link_libraries(TxVideoApp PRIVATE memif ${CMAKE_THREAD_LIBS_INIT} ${BSD_LIB} mcm_dp)
+target_link_libraries(RxVideoApp PRIVATE memif ${CMAKE_THREAD_LIBS_INIT} ${BSD_LIB} mcm_dp)
+target_link_libraries(TxAudioApp PRIVATE memif ${CMAKE_THREAD_LIBS_INIT} ${BSD_LIB} mcm_dp)
+target_link_libraries(RxAudioApp PRIVATE memif ${CMAKE_THREAD_LIBS_INIT} ${BSD_LIB} mcm_dp)
+target_link_libraries(TxBlobApp PRIVATE memif ${CMAKE_THREAD_LIBS_INIT} ${BSD_LIB} mcm_dp)
+target_link_libraries(RxBlobApp PRIVATE memif ${CMAKE_THREAD_LIBS_INIT} ${BSD_LIB} mcm_dp)
diff --git a/tests/tools/TestApp/Inc/json_context.h b/tests/tools/TestApp/Inc/json_context.h
index d3e9f8d..8d09c9a 100644
--- a/tests/tools/TestApp/Inc/json_context.h
+++ b/tests/tools/TestApp/Inc/json_context.h
@@ -9,6 +9,8 @@
  #include "mesh_dp.h"
 
  MeshConfig_Video get_video_params(MeshConnection *conn);
+ int get_payload_type(MeshConnection *conn);
+ MeshConfig_Audio get_audio_params(MeshConnection *conn);
  
  #endif /* _JSON_CONTEXT_ */
  
\ No newline at end of file
diff --git a/tests/tools/TestApp/Inc/mcm.h b/tests/tools/TestApp/Inc/mcm.h
index fc7757e..fbb5520 100644
--- a/tests/tools/TestApp/Inc/mcm.h
+++ b/tests/tools/TestApp/Inc/mcm.h
@@ -11,11 +11,14 @@
 #include <stdio.h>
 #include "mesh_dp.h"
 
+
 int mcm_init_client(MeshConnection **connection, MeshClient *client, const char *cfg);
 int mcm_create_tx_connection(MeshConnection *connection, MeshClient *client, const char *cfg);
 int mcm_create_rx_connection(MeshConnection *connection, MeshClient *client, const char *cfg);
-int mcm_send_video_frames(MeshConnection *connection, const char *filename, int (*graceful_shutdown)(void));
-void read_data_in_loop(MeshConnection *connection, const char *filename, int (*graceful_shutdown)(void));
+int mcm_send_video_frames(MeshConnection *connection, const char *filename);
+int mcm_send_audio_packets(MeshConnection *connection, const char *filename);
+int mcm_send_blob_packets(MeshConnection *connection, const char *filename);
+void read_data_in_loop(MeshConnection *connection, const char *filename);
 int is_root();
 
 #endif /* _MCM_H_ */
diff --git a/tests/tools/TestApp/Inc/misc.h b/tests/tools/TestApp/Inc/misc.h
index f26bf79..2ea11a6 100644
--- a/tests/tools/TestApp/Inc/misc.h
+++ b/tests/tools/TestApp/Inc/misc.h
@@ -7,6 +7,10 @@
 #ifndef _MISC_H_
 #define _MISC_H_
 
+#define SHUTDOWN_REQUESTED 1
+
 void LOG(const char *format, ...);
+void setup_sig_int();
+extern int shutdown_flag;
 
 #endif /* _MISC_H_ */
diff --git a/tests/tools/TestApp/rx_audio_app.c b/tests/tools/TestApp/rx_audio_app.c
new file mode 100644
index 0000000..ca9a73d
--- /dev/null
+++ b/tests/tools/TestApp/rx_audio_app.c
@@ -0,0 +1,73 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2025 Intel Corporation
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+ #include <stdio.h>
+ #include <string.h>
+ #include <stdlib.h>
+ #include <unistd.h>
+ #include <signal.h>
+ 
+ #include "Inc/input.h"
+ #include "Inc/mcm.h"
+ #include "Inc/misc.h"
+
+char *client_cfg;
+char *conn_cfg;
+MeshConnection *connection = NULL;
+MeshClient *client = NULL;
+
+int main(int argc, char *argv[]) {
+    setup_sig_int();
+    if (!is_root()) {
+        fprintf(stderr, "This program must be run as root. Exiting.\n");
+        exit(EXIT_FAILURE);
+    }
+    if (argc != 4) {
+        fprintf(stderr, "Usage: %s <client_cfg.json> <connection_cfg.json> <path_to_output_file>\n",
+                argv[0]);
+        exit(EXIT_FAILURE);
+    }
+
+    char *client_cfg_file = argv[1];
+    char *conn_cfg_file = argv[2];
+    char *out_filename = argv[3];
+
+    LOG("[RX] Launching RX App");
+    LOG("[RX] Reading client configuration...");
+    client_cfg = parse_json_to_string(client_cfg_file);
+    LOG("[RX] Reading connection configuration...");
+    conn_cfg = parse_json_to_string(conn_cfg_file);
+
+    /* Initialize mcm client */
+    int err = mesh_create_client_json(&client, client_cfg);
+    if (err) {
+        LOG("[RX] Failed to create mesh client: %s (%d)", mesh_err2str(err), err);
+        goto safe_exit;
+    }
+
+    /* Create mesh connection */
+    err = mesh_create_rx_connection(client, &connection, conn_cfg);
+    if (err) {
+        LOG("[RX] Failed to create connection: %s (%d)", mesh_err2str(err), err);
+        goto safe_exit;
+    }
+    LOG("[RX] Waiting for packets...");
+    read_data_in_loop(connection, out_filename);
+
+safe_exit:
+    LOG("[RX] SIGINT interrupt, dropping connection to media-proxy...");
+    if (connection) {
+        LOG("[RX] Shuting down connection");
+        mesh_delete_connection(&connection);
+    }
+    if (client) {
+        LOG("[RX] Shuting down client");
+        mesh_delete_client(&client);
+    }
+    free(client_cfg);
+    free(conn_cfg);
+    return err;
+}
diff --git a/tests/tools/TestApp/rx_blob_app.c b/tests/tools/TestApp/rx_blob_app.c
new file mode 100644
index 0000000..f755dd2
--- /dev/null
+++ b/tests/tools/TestApp/rx_blob_app.c
@@ -0,0 +1,67 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <signal.h>
+
+#include "Inc/input.h"
+#include "Inc/mcm.h"
+#include "Inc/misc.h"
+
+char *client_cfg;
+char *conn_cfg;
+MeshConnection *connection = NULL;
+MeshClient *client = NULL;
+
+int main(int argc, char *argv[]) {
+   setup_sig_int();
+   if (!is_root()) {
+       fprintf(stderr, "This program must be run as root. Exiting.\n");
+       exit(EXIT_FAILURE);
+   }
+   if (argc != 4) {
+       fprintf(stderr, "Usage: %s <client_cfg.json> <connection_cfg.json> <path_to_output_file>\n",
+               argv[0]);
+       exit(EXIT_FAILURE);
+   }
+
+   char *client_cfg_file = argv[1];
+   char *conn_cfg_file = argv[2];
+   char *out_filename = argv[3];
+
+   LOG("[RX] Launching RX App");
+   LOG("[RX] Reading client configuration...");
+   client_cfg = parse_json_to_string(client_cfg_file);
+   LOG("[RX] Reading connection configuration...");
+   conn_cfg = parse_json_to_string(conn_cfg_file);
+
+   /* Initialize mcm client */
+   int err = mesh_create_client_json(&client, client_cfg);
+   if (err) {
+       LOG("[RX] Failed to create mesh client: %s (%d)", mesh_err2str(err), err);
+       goto safe_exit;
+   }
+
+   /* Create mesh connection */
+   err = mesh_create_rx_connection(client, &connection, conn_cfg);
+   if (err) {
+       LOG("[RX] Failed to create connection: %s (%d)", mesh_err2str(err), err);
+       goto safe_exit;
+   }
+   LOG("[RX] Waiting for packets...");
+   read_data_in_loop(connection, out_filename);
+
+safe_exit:
+   LOG("[RX] SIGINT interrupt, dropping connection to media-proxy...");
+   if (connection) {
+       LOG("[RX] Shuting down connection");
+       mesh_delete_connection(&connection);
+   }
+   if (client) {
+       LOG("[RX] Shuting down client");
+       mesh_delete_client(&client);
+   }
+   free(client_cfg);
+   free(conn_cfg);
+   return err;
+}
\ No newline at end of file
diff --git a/tests/tools/TestApp/rx_app.c b/tests/tools/TestApp/rx_video_app.c
similarity index 64%
rename from tests/tools/TestApp/rx_app.c
rename to tests/tools/TestApp/rx_video_app.c
index a51cccd..c6b6c38 100644
--- a/tests/tools/TestApp/rx_app.c
+++ b/tests/tools/TestApp/rx_video_app.c
@@ -4,34 +4,23 @@
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
-#include <stdio.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include "Inc/input.h"
-#include "Inc/mcm.h"
-#include "Inc/misc.h"
-#include <signal.h>
+ #include <stdio.h>
+ #include <string.h>
+ #include <stdlib.h>
+ #include <unistd.h>
+ #include <signal.h>
+ 
+ #include "Inc/input.h"
+ #include "Inc/mcm.h"
+ #include "Inc/misc.h"
 
 char *client_cfg;
 char *conn_cfg;
 MeshConnection *connection = NULL;
 MeshClient *client = NULL;
-struct sigaction sa;
-
-#define SHUTDOWN_REQUESTED 1
-struct sigaction sa_int;
-struct sigaction sa_term;
-int shutdown = 0;
-
-void sig_handler(int sig);
-void setup_signal_handler(struct sigaction *sa, void (*handler)(int),int sig);
-int is_shutdown_requested();
 
 int main(int argc, char *argv[]) {
-    struct sigaction sa_int;
-    struct sigaction sa_term;
-    setup_signal_handler(&sa_int, sig_handler, SIGINT);
-    setup_signal_handler(&sa_term, sig_handler, SIGTERM);
+    setup_sig_int();
     if (!is_root()) {
         fprintf(stderr, "This program must be run as root. Exiting.\n");
         exit(EXIT_FAILURE);
@@ -66,7 +55,7 @@ int main(int argc, char *argv[]) {
         goto safe_exit;
     }
     LOG("[RX] Waiting for frames...");
-    read_data_in_loop(connection, out_filename, is_shutdown_requested);
+    read_data_in_loop(connection, out_filename);
 
 safe_exit:
     LOG("[RX] SIGINT interrupt, dropping connection to media-proxy...");
@@ -82,17 +71,3 @@ safe_exit:
     free(conn_cfg);
     return err;
 }
-int is_shutdown_requested() {
-    return shutdown;
-}
-
-void sig_handler(int sig) {
-    shutdown = SHUTDOWN_REQUESTED;
-}
-
-void setup_signal_handler(struct sigaction *sa, void (*handler)(int),int sig) {
-    sa->sa_handler = handler;
-    sigemptyset(&(sa->sa_mask));
-    sa->sa_flags = 0;
-    sigaction(sig, sa, NULL);
-}
diff --git a/tests/tools/TestApp/src/json_context.cc b/tests/tools/TestApp/src/json_context.cc
index 29aa431..7c92885 100644
--- a/tests/tools/TestApp/src/json_context.cc
+++ b/tests/tools/TestApp/src/json_context.cc
@@ -3,6 +3,12 @@
 
 namespace mesh {
   extern "C" {
+
+    int get_payload_type(MeshConnection *conn){
+      ConnectionContext *conn_ctx = (ConnectionContext *)conn;
+      return conn_ctx->cfg_json.payload_type;
+    }
+
     MeshConfig_Video get_video_params(MeshConnection *conn){
       ConnectionContext *conn_ctx = (ConnectionContext *)conn;
       return (MeshConfig_Video){
@@ -12,5 +18,14 @@ namespace mesh {
         .pixel_format = conn_ctx->cfg_json.payload.video.pixel_format
       };
     }
+    MeshConfig_Audio get_audio_params(MeshConnection *conn){
+      ConnectionContext *conn_ctx = (ConnectionContext *)conn;
+      return (MeshConfig_Audio){
+        .channels = conn_ctx->cfg_json.payload.audio.channels,
+        .sample_rate = conn_ctx->cfg_json.payload.audio.sample_rate,
+        .format  = conn_ctx->cfg_json.payload.audio.format,
+        .packet_time = conn_ctx->cfg_json.payload.audio.packet_time
+      };
+    }
   }
 }
diff --git a/tests/tools/TestApp/src/mcm.c b/tests/tools/TestApp/src/mcm.c
index 02bc6e7..0551ffd 100644
--- a/tests/tools/TestApp/src/mcm.c
+++ b/tests/tools/TestApp/src/mcm.c
@@ -14,10 +14,12 @@
 #include "json_context.h"
 
 #define SECOND_IN_US (double)1000000.0
+#define BLOB_DELAY_IN_US (uint32_t)1000 //1ms
 /* PRIVATE */
 void buffer_to_file(FILE *file, MeshBuffer *buf);
 
-int mcm_send_video_frames(MeshConnection *connection, const char *filename, int (*graceful_shutdown)(void)) {
+
+int mcm_send_video_frames(MeshConnection *connection, const char *filename) {
     MeshConfig_Video video_cfg = get_video_params(connection);
     LOG("[TX] Video configuration: %dx%d @ %.2f fps", video_cfg.width, video_cfg.height, video_cfg.fps);
     LOG("[TX] Video pixel format: %d", video_cfg.pixel_format);
@@ -49,16 +51,19 @@ int mcm_send_video_frames(MeshConnection *connection, const char *filename, int
         }
         read_size = fread(buf->payload_ptr, 1, buf->payload_len, file);
         if (read_size == 0) {
+            mesh_buffer_set_payload_len(buf, 0);
+            mesh_put_buffer(&buf);
             goto close_file;
         }
-
+        /* mesh buffer set payload API func* f(read_size) (1-payload_len)/
+        /* int mesh_buffer_set_payload_len */
         /* Send the buffer */
         err = mesh_put_buffer(&buf);
         if (err) {
             LOG("[TX] Failed to put buffer: %s (%d)", mesh_err2str(err), err);
             goto close_file;
         }
-        if (graceful_shutdown && graceful_shutdown() != 0 ) {
+        if (shutdown_flag  != 0 ) {
             LOG("[TX] Graceful shutdown requested");
             goto close_file;
         }
@@ -78,7 +83,155 @@ close_file:
     return err;
 }
 
-void read_data_in_loop(MeshConnection *connection, const char *filename, int (*graceful_shutdown)(void)) {
+int mcm_send_audio_packets(MeshConnection *connection, const char *filename) {
+    /* 
+        packet_time, format, sample_rate match tables,
+        order as in Media-Communications-Mesh/sdk/include/mesh_dp.hL231
+    */
+    int packet_time_convert_table_us[] = {1000, 125, 250, 333, 4000, 80, 1009, 140, 90};
+    char* format_convert_table_str[] = {"pcms8", "pcms16be", "pcms24be"};
+    int sample_rate_convert_table[] = {48000, 96000, 44100};
+    MeshConfig_Audio audio_cfg = get_audio_params(connection);
+    LOG("[TX] Audio configuration: channels: %d sample_rate: %d packet_time: %.2f", audio_cfg.channels, 
+        sample_rate_convert_table[audio_cfg.sample_rate], 
+        packet_time_convert_table_us[audio_cfg.packet_time]);
+    LOG("[TX] Audio format: %d", format_convert_table_str[audio_cfg.format]);
+    int err = 0;
+    MeshBuffer *buf;
+    FILE *file = fopen(filename, "rb");
+    if (file == NULL) {
+        LOG("[TX] Failed to serialize audio: file is null");
+        err = 1;
+        return err;
+    }
+    unsigned int frame_num = 0;
+    size_t read_size = 1;
+    int sleep_us = packet_time_convert_table_us[audio_cfg.packet_time];
+    struct timespec ts_begin = {}, ts_end = {};
+    struct timespec ts_frame_begin = {}, ts_frame_end = {};
+    __useconds_t elapsed = 0;
+    while (1) {
+        clock_gettime(CLOCK_REALTIME, &ts_frame_begin);
+        LOG("[TX] Sending packet: %d", ++frame_num);
+
+        /* Ask the mesh to allocate a shared memory buffer for user data */
+        err = mesh_get_buffer(connection, &buf);
+        if (err) {
+            LOG("[TX] Failed to get buffer: %s (%d)", mesh_err2str(err), err);
+            goto close_file;
+        }
+        read_size = fread(buf->payload_ptr, 1, buf->payload_len, file);
+        if (read_size == 0) {
+            mesh_buffer_set_payload_len(buf, 0);
+            mesh_put_buffer(&buf);
+            goto close_file;
+        }
+        if (read_size > buf->payload_len) {
+            LOG("[TX] read_size is bigger than payload_len: %s (%d)", mesh_err2str(err), err);
+            mesh_buffer_set_payload_len(buf, 0);
+            mesh_put_buffer(&buf);
+            goto close_file;
+        }
+        err = mesh_buffer_set_payload_len(buf, read_size);
+        if (err) {
+            LOG("[TX] Failed to set buffer_len: %s (%d)", mesh_err2str(err), err);
+        }
+        err = mesh_put_buffer(&buf);
+        if (err) {
+            LOG("[TX] Failed to put buffer: %s (%d)", mesh_err2str(err), err);
+            goto close_file;
+        }
+        if (shutdown_flag  != 0 ) {
+            LOG("[TX] Graceful shutdown requested");
+            goto close_file;
+        }
+        clock_gettime(CLOCK_REALTIME, &ts_frame_end);
+        elapsed = 1000000 * (ts_frame_end.tv_sec - ts_frame_begin.tv_sec) + (ts_frame_end.tv_nsec - ts_frame_begin.tv_nsec)/1000;
+        if (sleep_us - elapsed >= 0) {
+            usleep(sleep_us - elapsed);
+            LOG("[TX] Elapsed: %d; Slept: %d", elapsed, sleep_us - elapsed);
+        }
+        else {
+            LOG("[TX] Cannot keep the pace with %d time!", audio_cfg.packet_time);
+        }
+    }
+    LOG("[TX] data sent successfully");
+close_file:
+    fclose(file);
+    return err;
+}
+
+int mcm_send_blob_packets(MeshConnection *connection, const char *filename) {
+    LOG("[TX] sending blob packets");
+    int err = 0;
+    MeshBuffer *buf;
+    FILE *file = fopen(filename, "rb");
+    if (file == NULL) {
+        LOG("[TX] Failed to serialize audio: file is null");
+        err = 1;
+        return err;
+    }
+    
+    /* execute cpp class code  here */
+    unsigned int frame_num = 0;
+    size_t read_size = 1;
+    int sleep_us = BLOB_DELAY_IN_US;
+    struct timespec ts_begin = {}, ts_end = {};
+    struct timespec ts_frame_begin = {}, ts_frame_end = {};
+    __useconds_t elapsed = 0;
+    while (1) {
+        clock_gettime(CLOCK_REALTIME, &ts_frame_begin);
+        LOG("[TX] Sending packet: %d", ++frame_num);
+
+        /* Ask the mesh to allocate a shared memory buffer for user data */
+        err = mesh_get_buffer(connection, &buf);
+        if (err) {
+            LOG("[TX] Failed to get buffer: %s (%d)", mesh_err2str(err), err);
+            goto close_file;
+        }
+        read_size = fread(buf->payload_ptr, 1, buf->payload_len, file);
+        if (read_size == 0) {
+            mesh_buffer_set_payload_len(buf, 0);
+            mesh_put_buffer(&buf);
+            goto close_file;
+        }
+        if (read_size > buf->payload_len) {
+            LOG("[TX] read_size is bigger than payload_len: %s (%d)", mesh_err2str(err), err);
+            mesh_buffer_set_payload_len(buf, 0);
+            mesh_put_buffer(&buf);
+            goto close_file;
+        }
+        err = mesh_buffer_set_payload_len(buf, read_size);
+        if (err ) {
+            LOG("[TX] Failed to set buffer_len: %s (%d)", mesh_err2str(err), err);
+        }
+        err = mesh_put_buffer(&buf);
+        if (err) {
+            LOG("[TX] Failed to put buffer: %s (%d)", mesh_err2str(err), err);
+            goto close_file;
+        }
+        if (shutdown_flag  != 0 ) {
+            LOG("[TX] Graceful shutdown requested");
+            goto close_file;
+        }
+        clock_gettime(CLOCK_REALTIME, &ts_frame_end);
+        elapsed = 1000000 * (ts_frame_end.tv_sec - ts_frame_begin.tv_sec) + (ts_frame_end.tv_nsec - ts_frame_begin.tv_nsec)/1000;
+        if (sleep_us - elapsed >= 0) {
+            usleep(sleep_us - elapsed);
+            LOG("[TX] Elapsed: %d; Slept: %d", elapsed, sleep_us - elapsed);
+        }
+        else {
+            LOG("[TX] Cannot keep the pace with %d time!", BLOB_DELAY_IN_US);
+        }
+    }
+    LOG("[TX] data sent successfully");
+close_file:
+   fclose(file);
+    return err;
+}
+
+
+void read_data_in_loop(MeshConnection *connection, const char *filename) {
     int timeout = MESH_TIMEOUT_INFINITE;
     int frame = 0;
     int err = 0;
@@ -88,9 +241,7 @@ void read_data_in_loop(MeshConnection *connection, const char *filename, int (*g
 
         /* Set loop's  error*/
         err = 0;
-        if (frame) {
-            timeout = 1000;
-        }
+        timeout = (frame) ? 1000 : MESH_TIMEOUT_INFINITE;
 
         /* Receive a buffer from the mesh */
         err = mesh_get_buffer_timeout(connection, &buf, timeout);
@@ -112,7 +263,7 @@ void read_data_in_loop(MeshConnection *connection, const char *filename, int (*g
             break;
         }
         LOG("[RX] Frame: %d", ++frame);
-        if (graceful_shutdown && graceful_shutdown() != 0 ) {
+        if (shutdown_flag != 0) {
             LOG("[RX] Graceful shutdown requested");
             break;
         }
@@ -121,6 +272,7 @@ void read_data_in_loop(MeshConnection *connection, const char *filename, int (*g
     LOG("[RX] Done reading the data");
 }
 
+/* common for video, audio, blob*/
 void buffer_to_file(FILE *file, MeshBuffer *buf) {
     if (file == NULL) {
         LOG("[RX] Failed to open file for writing");
@@ -132,4 +284,3 @@ void buffer_to_file(FILE *file, MeshBuffer *buf) {
 }
 
 int is_root() { return geteuid() == 0; }
-
diff --git a/tests/tools/TestApp/src/misc.c b/tests/tools/TestApp/src/misc.c
index c3f54fa..28f008c 100644
--- a/tests/tools/TestApp/src/misc.c
+++ b/tests/tools/TestApp/src/misc.c
@@ -9,6 +9,15 @@
 #include <stdio.h>
 #include <stdarg.h>
 #include <time.h>
+#include <signal.h>
+
+int shutdown_flag = 0;
+
+struct sigaction sa_int;
+struct sigaction sa_term;
+
+void sig_handler(int sig);
+void setup_signal_handler(struct sigaction *sa, void (*handler)(int),int sig);
 
 void LOG(const char *format, ...) {
     time_t rawtime;
@@ -31,3 +40,23 @@ void LOG(const char *format, ...) {
 
     printf("\n");
 }
+
+
+void setup_sig_int(){
+    static struct sigaction sa_int;
+    static struct sigaction sa_term;
+    setup_signal_handler(&sa_int, sig_handler, SIGINT);
+    setup_signal_handler(&sa_term, sig_handler, SIGTERM);
+}
+
+
+void sig_handler(int sig) {
+    shutdown_flag = SHUTDOWN_REQUESTED;
+}
+
+void setup_signal_handler(struct sigaction *sa, void (*handler)(int),int sig) {
+    sa->sa_handler = handler;
+    sigemptyset(&(sa->sa_mask));
+    sa->sa_flags = 0;
+    sigaction(sig, sa, NULL);
+}
diff --git a/tests/tools/TestApp/tx_audio_app.c b/tests/tools/TestApp/tx_audio_app.c
new file mode 100644
index 0000000..5a9f655
--- /dev/null
+++ b/tests/tools/TestApp/tx_audio_app.c
@@ -0,0 +1,81 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2025 Intel Corporation
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+ #include <stdio.h>
+ #include <string.h>
+ #include <stdlib.h>
+ #include <unistd.h>
+ #include <signal.h>
+ 
+ #include "Inc/input.h"
+ #include "Inc/mcm.h"
+ #include "Inc/misc.h"
+ 
+ 
+ char *client_cfg;
+ char *conn_cfg;
+ MeshConnection *connection = NULL;
+ MeshClient *client = NULL;
+ 
+ int main(int argc, char **argv) {
+     setup_sig_int();
+     if (!is_root()) {
+         fprintf(stderr, "This program must be run as root. Exiting.\n");
+         exit(EXIT_FAILURE);
+     }
+     if (argc != 4) {
+         fprintf(stderr, "Usage: %s <client_cfg.json> <connection_cfg.json> <path_to_input_file>\n",
+                 argv[0]);
+         exit(EXIT_FAILURE);
+     }
+ 
+     char *client_cfg_file = argv[1];
+     char *conn_cfg_file = argv[2];
+     char *video_file = argv[3];
+ 
+     LOG("[TX] Launching TX app");
+     
+     LOG("[TX] Reading client configuration...");
+     client_cfg = parse_json_to_string(client_cfg_file);
+     LOG("[TX] Reading connection configuration...");
+     conn_cfg = parse_json_to_string(conn_cfg_file);
+ 
+     /* Initialize mcm client */
+     int err = mesh_create_client_json(&client, client_cfg);
+     if (err) {
+         LOG("[TX] Failed to create mesh client: %s (%d)", mesh_err2str(err), err);
+         goto safe_exit;
+     }
+ 
+     /* Create mesh connection */
+     err = mesh_create_tx_connection(client, &connection, conn_cfg);
+     if (err) {
+         LOG("[TX] Failed to create connection: %s (%d)", mesh_err2str(err), err);
+         goto safe_exit;
+     }
+ 
+     /* Open file and send its contents in loop*/
+     while(1){
+         err = mcm_send_audio_packets(connection, video_file);
+         if ( shutdown_flag == SHUTDOWN_REQUESTED ) {
+             goto safe_exit;
+         }
+     }
+ safe_exit:
+     LOG("[TX] shut down request, dropping connection to media-proxy...");
+     LOG("[TX] Shuting down connection");
+     if (connection) {
+         mesh_delete_connection(&connection);
+     }
+     LOG("[TX] Shuting down client");
+     if (client) {
+         mesh_delete_client(&client);
+     }
+     free(client_cfg);
+     free(conn_cfg);
+     return err;
+ }
+ 
\ No newline at end of file
diff --git a/tests/tools/TestApp/tx_blob_app.c b/tests/tools/TestApp/tx_blob_app.c
new file mode 100644
index 0000000..87304af
--- /dev/null
+++ b/tests/tools/TestApp/tx_blob_app.c
@@ -0,0 +1,81 @@
+/*
+ * SPDX-FileCopyrightText: Copyright (c) 2025 Intel Corporation
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+ #include <stdio.h>
+ #include <string.h>
+ #include <stdlib.h>
+ #include <unistd.h>
+ #include <signal.h>
+ 
+ #include "Inc/input.h"
+ #include "Inc/mcm.h"
+ #include "Inc/misc.h"
+ 
+ 
+ char *client_cfg;
+ char *conn_cfg;
+ MeshConnection *connection = NULL;
+ MeshClient *client = NULL;
+ 
+ int main(int argc, char **argv) {
+     setup_sig_int();
+     if (!is_root()) {
+         fprintf(stderr, "This program must be run as root. Exiting.\n");
+         exit(EXIT_FAILURE);
+     }
+     if (argc != 4) {
+         fprintf(stderr, "Usage: %s <client_cfg.json> <connection_cfg.json> <path_to_input_file>\n",
+                 argv[0]);
+         exit(EXIT_FAILURE);
+     }
+ 
+     char *client_cfg_file = argv[1];
+     char *conn_cfg_file = argv[2];
+     char *video_file = argv[3];
+ 
+     LOG("[TX] Launching TX app");
+     
+     LOG("[TX] Reading client configuration...");
+     client_cfg = parse_json_to_string(client_cfg_file);
+     LOG("[TX] Reading connection configuration...");
+     conn_cfg = parse_json_to_string(conn_cfg_file);
+ 
+     /* Initialize mcm client */
+     int err = mesh_create_client_json(&client, client_cfg);
+     if (err) {
+         LOG("[TX] Failed to create mesh client: %s (%d)", mesh_err2str(err), err);
+         goto safe_exit;
+     }
+ 
+     /* Create mesh connection */
+     err = mesh_create_tx_connection(client, &connection, conn_cfg);
+     if (err) {
+         LOG("[TX] Failed to create connection: %s (%d)", mesh_err2str(err), err);
+         goto safe_exit;
+     }
+ 
+     /* Open file and send its contents in loop*/
+     while(1){
+         err = mcm_send_blob_packets(connection, video_file);
+         if ( shutdown_flag == SHUTDOWN_REQUESTED ) {
+             goto safe_exit;
+         }
+     }
+ safe_exit:
+     LOG("[TX] shut down request, dropping connection to media-proxy...");
+     LOG("[TX] Shuting down connection");
+     if (connection) {
+         mesh_delete_connection(&connection);
+     }
+     LOG("[TX] Shuting down client");
+     if (client) {
+         mesh_delete_client(&client);
+     }
+     free(client_cfg);
+     free(conn_cfg);
+     return err;
+ }
+ 
\ No newline at end of file
diff --git a/tests/tools/TestApp/tx_app.c b/tests/tools/TestApp/tx_video_app.c
similarity index 71%
rename from tests/tools/TestApp/tx_app.c
rename to tests/tools/TestApp/tx_video_app.c
index 4d94665..20e2b28 100644
--- a/tests/tools/TestApp/tx_app.c
+++ b/tests/tools/TestApp/tx_video_app.c
@@ -14,24 +14,14 @@
 #include "Inc/mcm.h"
 #include "Inc/misc.h"
 
-#define SHUTDOWN_REQUESTED 1
-
 
 char *client_cfg;
 char *conn_cfg;
 MeshConnection *connection = NULL;
 MeshClient *client = NULL;
-struct sigaction sa_int;
-struct sigaction sa_term;
-int shutdown = 0;
-
-void sig_handler(int sig);
-void setup_signal_handler(struct sigaction *sa, void (*handler)(int),int sig);
-int is_shutdown_requested();
 
 int main(int argc, char **argv) {
-    setup_signal_handler(&sa_int, sig_handler, SIGINT);
-    setup_signal_handler(&sa_term, sig_handler, SIGTERM);
+    setup_sig_int();
     if (!is_root()) {
         fprintf(stderr, "This program must be run as root. Exiting.\n");
         exit(EXIT_FAILURE);
@@ -69,8 +59,8 @@ int main(int argc, char **argv) {
 
     /* Open file and send its contents in loop*/
     while(1){
-        err = mcm_send_video_frames(connection, video_file, is_shutdown_requested);
-        if ( shutdown == SHUTDOWN_REQUESTED ) {
+        err = mcm_send_video_frames(connection, video_file);
+        if ( shutdown_flag == SHUTDOWN_REQUESTED ) {
             goto safe_exit;
         }
     }
@@ -88,18 +78,3 @@ safe_exit:
     free(conn_cfg);
     return err;
 }
-int is_shutdown_requested() {
-    return shutdown;
-}
-
-void sig_handler(int sig) {
-        shutdown = SHUTDOWN_REQUESTED;
-}
-
-void setup_signal_handler(struct sigaction *sa, void (*handler)(int),int sig) {
-    sa->sa_handler = handler;
-    sigemptyset(&(sa->sa_mask));
-    sa->sa_flags = 0;
-    sigaction(sig, sa, NULL);
-}
-
